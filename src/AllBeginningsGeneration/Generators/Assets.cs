using AllBeginningsGeneration.Utilities;
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Immutable;
using System.IO;
using System.Linq;

namespace SourceGeneration.Generators;

internal enum AssetType {
    Texture2D,
    Effect
}

internal readonly record struct AssetFile(string Path, string Folder, string Name, string Extension, AssetType AssetType) {
    public string Path { get; } = Path;
    public string Folder { get; } = Folder;
    public string Name { get; } = Name;
    public string Extension { get; } = Extension;
    public AssetType AssetType { get; } = AssetType;
}

[Generator(LanguageNames.CSharp)]
internal sealed class AssetGenerator : IIncrementalGenerator
{
    private const string image_extension = ".png";
    private const string effect_extension = ".fxc";

    private const string build_manifest_filename = "build.txt";

    private const string mod_name = "AllBeginningsMod";

    private static readonly string[] supported_extensions = new[] { image_extension, effect_extension };

    private static readonly string initial_file_header;

    static AssetGenerator()
    {
        var writer = new IndentedStringWriter(512);
        writer.WriteLine("// <auto-generated/>");

        writer.WriteLine(@"
using ReLogic.Content;
using Microsoft.Xna.Framework.Graphics;
using Terraria.ModLoader;
using System;

using ImageAsset = ReLogic.Content.Asset<Microsoft.Xna.Framework.Graphics.Texture2D>;
using EffectAsset = ReLogic.Content.Asset<Microsoft.Xna.Framework.Graphics.Effect>;
");

        writer.WriteLine($"namespace {mod_name}.Assets;");
        initial_file_header = writer.ToString();
    }

    void IIncrementalGenerator.Initialize(IncrementalGeneratorInitializationContext context)
    {
        var assetRootFolder = context.AdditionalTextsProvider
            .Where(file => file.Path.EndsWith(build_manifest_filename))
            .Collect()
            .Select(static (files, _) =>
            {
                var directory = Path.GetDirectoryName(files.FirstOrDefault()?.Path)?.Replace('\\', '/');
                if (string.IsNullOrWhiteSpace(directory))
                    return null;

                return directory;
            });


        /*
            asset files are grouped by directory
            one generated file per asset is technically the most efficient, but itd generate way too many files
            one generated file with all assets would generate a very large file, which the compiler might not like
            and changing one fill would necessitate an entire file rebuild

            grouping by directory only triggers a rebuild for the directory a file belongs to
         */
        var contents = context.AdditionalTextsProvider
            .Where(static file => supported_extensions.Any(ext =>
                file.Path.EndsWith(ext, StringComparison.OrdinalIgnoreCase)
            ))
            .Select((file, _) => file.Path.Replace('\\', '/'))
            .Combine(assetRootFolder)
            .Where(tuple =>
                tuple.Right != null && tuple.Left.StartsWith(
                    tuple.Right.ToString(),
                    StringComparison.Ordinal
                )
            )
            .Select(static (tuple, _) =>
            {
                string fullPath = tuple.Left.Substring(tuple.Right.Length + 1);

                string path = Path.ChangeExtension(fullPath, null);
                string folder = Path.GetDirectoryName(fullPath)!.Replace('\\', '/');
                string name = Path.GetFileNameWithoutExtension(fullPath);
                string extension = Path.GetExtension(fullPath);


                if (folder.StartsWith("Assets/", StringComparison.OrdinalIgnoreCase))
                    folder = folder.Substring("Assets/".Length);

                //determine asset type based on file extension
                //exception should never be thrown in any case, but defensive anyways
                AssetType assetType = extension.Equals(image_extension, StringComparison.OrdinalIgnoreCase)
                    ? AssetType.Texture2D
                    : extension.Equals(effect_extension, StringComparison.OrdinalIgnoreCase)
                        ? AssetType.Effect
                        : throw new InvalidOperationException("how");

                return new AssetFile(
                    path,
                    folder,
                    name,
                    extension,
                    assetType
                );
            })
            .Collect()
            .SelectMany((files, _) => files.GroupBy(
                    f => f.Folder, 
                    f => f, 
                    (key, group) => (key, group.ToImmutableArray()))
                .ToImmutableArray()
            );

        context.RegisterSourceOutput(
            contents,
            (sourceContext, contentTuple) =>
            {
                var (folder, assetFiles) = contentTuple;

                sourceContext.CancellationToken.ThrowIfCancellationRequested();
                using IndentedStringWriter writer = new(1024);

                writer.WriteLine(initial_file_header);

                writer.WriteLine($@"partial class Assets {{");
                writer.Indent++;
                foreach (string part in folder.Split(new[] { '/' }, StringSplitOptions.RemoveEmptyEntries))
                {
                    writer.WriteLine($"public partial class {part} {{   ");
                    writer.Indent++;
                }

                foreach (var file in assetFiles)
                {
                    string assetPath = $"{mod_name}/{file.Path}";

                    writer.WriteLine($"public const string KEY_{file.Name} = \"{assetPath}\";");

                    string typeLazy = file.AssetType switch
                    {
                        AssetType.Texture2D =>
                            $"public readonly static Lazy<ImageAsset> {file.Name}_lazy = new(() => ModContent.Request<Texture2D>(\"{assetPath}\"));",
                        AssetType.Effect =>
                            $"public readonly static Lazy<EffectAsset> {file.Name}_lazy = new(() => ModContent.Request<Effect>(\"{assetPath}\", AssetRequestMode.ImmediateLoad));",
                        _ => throw new ArgumentOutOfRangeException()
                    };

                    string type = file.AssetType switch
                    {
                        AssetType.Texture2D =>
                            $"public static ImageAsset {file.Name} {{ get; }} = {file.Name}_lazy.Value;",
                        AssetType.Effect =>
                            $"public static EffectAsset {file.Name} {{ get; }} = ModContent.Request<Effect>(\"{assetPath}\", AssetRequestMode.ImmediateLoad);",
                        _ => throw new ArgumentOutOfRangeException()
                    };

                    writer.WriteLine(typeLazy);
                    writer.WriteLine(type);
                }

                foreach (string _ in folder.Split(new[] { '/' }, StringSplitOptions.RemoveEmptyEntries))
                {
                    writer.Indent--;
                    writer.WriteLine("}");
                }

                writer.Indent--;
                writer.WriteLine("}"); // Assets class

                string sourceText = writer.ToStringAndClear();

                writer.Write($"Assets.{folder}.cs");
                writer.Builder.Replace('/', '.');
                string fileName = writer.ToString();
                if (fileName.Equals("Assets..cs", StringComparison.Ordinal)) // file was on root
                {
                    fileName = "Assets.g.cs";
                }

                sourceContext.AddSource(fileName, sourceText);
            }
        );
    }
}